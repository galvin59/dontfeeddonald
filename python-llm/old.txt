import os
import json
import re
import requests
from typing import Dict, Any, Optional, List, Union
from pathlib import Path
from pydantic import BaseModel, Field, create_model
from brand_agents.logo_search import search_brand_logo

# Define our structured data models for brand information
class SourcedValue(BaseModel):
    """A value with a source URL"""
    value: Any
    source: Optional[str] = Field(None, description="URL source of the information")

class EconomicImpact(BaseModel):
    """Economic impact analysis with source"""
    analysis: str
    source: Optional[str] = Field(None, description="URL source of the analysis")

class BrandField(BaseModel):
    """Base class for brand field responses"""
    field_name: str
    brand: str

class TotalEmployeesField(BrandField):
    """Total employees field data"""
    total_employees: Optional[SourcedValue] = None

class EmployeesUSField(BrandField):
    """US employees field data"""
    employees_US: Optional[SourcedValue] = None

class EconomicImpactField(BrandField):
    """Economic impact field data"""
    economic_impact: Optional[EconomicImpact] = None

class FactoryInFranceField(BrandField):
    """Factory in France field data"""
    factory_in_france: Optional[SourcedValue] = None

class FactoryInEUField(BrandField):
    """Factory in EU field data"""
    factory_in_EU: Optional[SourcedValue] = None

class FrenchFarmerField(BrandField):
    """French farmer field data"""
    french_farmer: Optional[SourcedValue] = None

class EUFarmerField(BrandField):
    """EU farmer field data"""
    EU_farmer: Optional[SourcedValue] = None

class LogoUrlField(BrandField):
    """Logo URL field data"""
    logo_url: Optional[SourcedValue] = None

class SimilarBrandsEUField(BrandField):
    """Similar EU brands field data"""
    similar_brands_eu: Optional[List[str]] = None

# Import necessary langchain components
from langchain.agents import initialize_agent, AgentType
from langchain.agents.agent import AgentExecutor
from langchain_core.prompts import PromptTemplate
from langchain_community.utilities import SerpAPIWrapper, GoogleSearchAPIWrapper, WikipediaAPIWrapper
from langchain_community.tools import Tool
from langchain_community.chat_models import ChatOpenAI
from duckduckgo_search import DDGS
from langchain.agents.format_scratchpad import format_to_openai_function_messages
from langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser
from langchain.tools.render import format_tool_to_openai_function

# Import configuration
from config import (
    MISTRAL_BASE_URL,
    MISTRAL_API_KEY,
    SERPAPI_API_KEY,
    GOOGLE_API_KEY,
    GOOGLE_CSE_ID,
    WIKIPEDIA_CLIENT_ID,
    WIKIPEDIA_CLIENT_SECRET,
    WIKIPEDIA_ACCESS_TOKEN,
    WIKIPEDIA_USER_AGENT
)

# Web Search MCP function (reusing from agent_with_tools.py)
def web_search(query: str, limit: int = 5) -> List[Dict[str, str]]:
    """
    Search the web using the web-search MCP server
    
    Args:
        query: The search query
        limit: Number of results to return (default: 5, max: 10)
        
    Returns:
        List of search results with title, url, and description
    """
    try:
        # For the MCP server integration, we'll use a direct HTTP request
        url = "http://localhost:3000/search"
        
        response = requests.post(
            url,
            json={"query": query, "limit": min(limit, 10)},
            timeout=10
        )
        
        if response.status_code == 200:
            results = response.json()
            formatted_results = ""
            
            for i, result in enumerate(results, start=1):
                formatted_results += f"Result {i}:\n"
                formatted_results += f"Title: {result.get('title', 'No title')}\n"
                formatted_results += f"URL: {result.get('url', 'No URL')}\n"
                formatted_results += f"Description: {result.get('description', 'No description')}\n\n"
                
            return formatted_results or "No results found."
        else:
            print(f"Web search MCP server error: {response.status_code}")
            return f"Error: Unable to connect to web search service (HTTP {response.status_code})"
    
    except Exception as e:
        print(f"Error using web-search MCP server: {str(e)}")
        return f"Error performing web search: {str(e)}"

# Initialize the search tools
def get_search_tools() -> List[Tool]:
    """
    Create and return a list of available search tools
    """
    tools = []
    
    # Wikipedia search tool with OAuth authentication if credentials are provided
    try:
        # Using Wikipedia's search API
        wikipedia_search = WikipediaAPIWrapper(
            top_k_results=5,
            lang="en"
        )
        tools.append(
            Tool(
                name="Wikipedia",
                description="Search for information about brands and companies on Wikipedia. Use this for finding general information about companies, their history, and their structure.",
                func=wikipedia_search.run
            )
        )
        print("Wikipedia search tool initialized successfully")
    except Exception as e:
        print(f"Error initializing Wikipedia search tool: {str(e)}")
    
    # SerpAPI search if API key is provided
    if SERPAPI_API_KEY:
        try:
            serp_search = SerpAPIWrapper(serpapi_api_key=SERPAPI_API_KEY)
            tools.append(
                Tool(
                    name="Web Search",
                    description="Search the web for real-time information about brands, companies, and their operations. Use this for finding the most up-to-date information.",
                    func=serp_search.run
                )
            )
            print("SerpAPI search tool initialized successfully")
        except Exception as e:
            print(f"Error initializing SerpAPI search tool: {str(e)}")
    
    # Google Custom Search if API key and CSE ID are provided
    if GOOGLE_API_KEY and GOOGLE_CSE_ID:
        try:
            google_search = GoogleSearchAPIWrapper(
                google_api_key=GOOGLE_API_KEY,
                google_cse_id=GOOGLE_CSE_ID
            )
            tools.append(
                Tool(
                    name="Google",
                    description="Search Google for specific information about brands, companies, and their manufacturing operations. Use this for finding detailed information.",
                    func=google_search.run
                )
            )
            print("Google Custom Search tool initialized successfully")
        except Exception as e:
            print(f"Error initializing Google Custom Search tool: {str(e)}")
    
    # Add Web Search MCP tool as a fallback
    try:
        tools.append(
            Tool(
                name="Web Search MCP",
                description="Search for information across the web. Use this when other search tools don't provide sufficient information.",
                func=web_search
            )
        )
        print("Web search MCP tool initialized successfully")
    except Exception as e:
        print(f"Error initializing web search MCP tool: {str(e)}")
    
    return tools

# Initialize the LLM with Mistral via LM Studio
def get_llm():
    """
    Create and return a ChatOpenAI instance configured for Mistral via LM Studio
    """
    return ChatOpenAI(
        openai_api_key=MISTRAL_API_KEY or "lm-studio",  # LM Studio typically doesn't need a key
        openai_api_base=MISTRAL_BASE_URL,
        model_name="mistral",  # This is typically ignored by LM Studio
        temperature=0.1,
        streaming=True
    )

# Field-specific prompt templates
PROMPT_TEMPLATES = {
    "parent_company": """
You are a specialist in brand ownership and company information.

TASK:
Find the parent company that owns the brand {brand} which produces {product_family} (this product category name is in French).

INSTRUCTIONS:
1. Focus specifically on finding the CURRENT OWNER of brand {brand}.
2. You should identify the name of the company that currently owns/exploits the brand.
3. Look for the TOP LEVEL PARENT COMPANY, not a local subsidiary. For instance, if a brand is owned by Unilever France, which is a subsidiary of the Unilever Group, use the Unilever Group.
4. Include the source URL or reference for the information.
5. Use the most recent data available.
6. If you cannot find reliable information or are uncertain, return null. It is better to return null than to guess or provide incorrect information.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "parent_company",
  "brand": "{brand}",
  "parent_company": null or {{ "value": "Full Company Name", "source": "URL or description of source" }}
}}
""",
    "brand_origin": """
You are a specialist in brand ownership and origins.

TASK:
Find the country of origin for the brand {brand} which is owned by {parent_company} and produces {product_family} (this product category name is in French).

INSTRUCTIONS:
1. CRITICAL: The "brand_origin" field MUST BE the headquarters country of the CURRENT top parent company (e.g., for Jameson, use France because Pernod Ricard is based in France, NOT Ireland where Jameson was founded).
2. You should not use the local subsidiary but look at the top level group: for instance, if a brand is owned by Unilever France, which is a subsidiary of the Unilever Group, use the headquarters country of the Unilever Group.
3. IMPORTANT: Return the country code in ISO 3166-1 alpha-2 format (2-letter country code, e.g., 'US' for United States, 'DE' for Germany, 'FR' for France).
4. Include the source URL or reference for the information.
5. Use the most reliable data available.
6. If you cannot find reliable information or are uncertain, return null. It is better to return null than to guess or provide incorrect information.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "brand_origin",
  "brand": "{brand}",
  "brand_origin": null or {{ "value": "XX", "source": "URL or description of source" }}
}}

Where XX is the 2-letter ISO country code.
""",
    "total_employees": """
You are a specialist in company workforce data.

TASK:
Find the total number of employees worldwide for the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French).

INSTRUCTIONS:
1. Focus specifically on finding the TOTAL NUMBER OF EMPLOYEES for the parent company of {brand} : {parent_company}
2. If you find a number, include the source URL or reference.
3. Use the most recent data available.
4. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "total_employees",
  "brand": "{brand}",
  "total_employees": null or {{ "value": "Number or approximate range", "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "employees_US": """
You are a specialist in company workforce data.

TASK:
Find the number of employees in the United States for the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French).

INSTRUCTIONS:
1. Focus specifically on finding the NUMBER OF US-BASED EMPLOYEES for the parent company of {brand} : {parent_company}.
2. If you find a number, include the source URL or reference.
3. Use the most recent data available.
4. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "employees_US",
  "brand": "{brand}",
  "employees_US": null or {{ "value": "Number or approximate range", "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "economic_impact": """
You are an economist specializing in international trade.

TASK:
Analyze whether a purchase of products from the brand {brand}, owned by {parent_company}, which produces {product_family} (this product category name is in French), in the EU would be more profitable for the US or non-US economy.

INSTRUCTIONS:
1. Consider where the brand is manufactured, where profits go, and employment impact.
2. Provide a brief analysis IN FRENCH about whether purchasing this brand benefits the US or non-US economy more.
3. If you find reliable information, include the source URL or reference.
4. If you cannot form a reliable analysis, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "economic_impact", 
  "brand": "{brand}",
  "economic_impact": null or {{ "analysis": "Brief analysis (in French) of whether buying this brand in the EU would be more profitable for the US or the EU economy.", "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "factory_in_france": """
You are a manufacturing supply chain specialist.

TASK:
Determine whether the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French) has one or more factories in France.

INSTRUCTIONS:
1. Focus on MANUFACTURING facilities, not just distribution, offices, or headquarters.
2. If you find information, include the source URL or reference.
3. Return true if there is evidence of manufacturing in France, false if there is evidence of no manufacturing in France.
4. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "factory_in_france",
  "brand": "{brand}",
  "factory_in_france": null or {{ "value": true/false, "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "factory_in_EU": """
You are a manufacturing supply chain specialist.

TASK:
Determine whether the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French) has one or more factories in any European Union country.

INSTRUCTIONS:
1. Focus on MANUFACTURING facilities, not just distribution, offices, or headquarters.
2. EU countries are: Austria, Belgium, Bulgaria, Croatia, Cyprus, Czech Republic, Denmark, Estonia, Finland, France, Germany, Greece, Hungary, Ireland, Italy, Latvia, Lithuania, Luxembourg, Malta, Netherlands, Poland, Portugal, Romania, Slovakia, Slovenia, Spain, Sweden.
3. If you find information, include the source URL or reference.
4. Return true if there is evidence of manufacturing in any EU country, false if there is evidence of no manufacturing in any EU country.
5. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "factory_in_EU",
  "brand": "{brand}",
  "factory_in_EU": null or {{ "value": true/false, "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "french_farmer": """
You are an agricultural supply chain specialist.

TASK:
Determine whether the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French) sources agricultural products from French or European Union farmers.

INSTRUCTIONS:
1. Focus on direct sourcing from farmers in France or any EU country, not just processing of ingredients in France or any EU country.
2. If the brand doesn't use agricultural products, respond with false.
3. If you find information, include the source URL or reference.
4. Return true if there is evidence of sourcing from French farmers, false if there's evidence of no sourcing from French farmers.
5. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "french_farmer",
  "brand": "{brand}",
  "french_farmer": null or {{ "value": true/false, "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "EU_farmer": """
You are an agricultural supply chain specialist.

TASK:
Determine whether the company {parent_company} that owns the brand {brand} which produces {product_family} (this product category name is in French) sources agricultural products from farmers in European Union countries.

INSTRUCTIONS:
1. Focus on direct sourcing from farmers in EU countries, not just processing of ingredients in the EU.
2. EU countries are: Austria, Belgium, Bulgaria, Croatia, Cyprus, Czech Republic, Denmark, Estonia, Finland, France, Germany, Greece, Hungary, Ireland, Italy, Latvia, Lithuania, Luxembourg, Malta, Netherlands, Poland, Portugal, Romania, Slovakia, Slovenia, Spain, Sweden.
3. If the brand doesn't use agricultural products, respond with false.
4. If you find information, include the source URL or reference.
5. Return true if there is evidence of sourcing from EU farmers, false if there's evidence of no sourcing from EU farmers.
6. If you cannot find reliable information, return null.

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "EU_farmer",
  "brand": "{brand}",
  "EU_farmer": null or {{ "value": true/false, "source": "URL or description of source" }}
}}

Only include the JSON in your response, with no additional text before or after.
    """,
    
    "similar_brands_eu": """
You are a market research specialist with deep knowledge of European brands.

TASK:
Find similar brands to {brand} that are based in or owned by companies from the European Union.

INSTRUCTIONS:
1. Identify brands that are similar to {brand} in product category, market position, and target audience.
2. Only include brands that are based in or owned by companies from EU countries.
3. EU countries are: Austria, Belgium, Bulgaria, Croatia, Cyprus, Czech Republic, Denmark, Estonia, Finland, France, Germany, Greece, Hungary, Ireland, Italy, Latvia, Lithuania, Luxembourg, Malta, Netherlands, Poland, Portugal, Romania, Slovakia, Slovenia, Spain, Sweden.
4. Return a list of up to 5 similar EU-based brands.
5. If you cannot find reliable information, return null.

CRITICAL: Each brand in the array must be a simple string containing ONLY the brand name. DO NOT include any additional information, descriptions, or ownership details in parentheses or any other format. For example, write "Milka" not "Milka (owned by Mondelez)".

FORMAT YOUR RESPONSE AS VALID JSON using this exact schema:
{{
  "field_name": "similar_brands_eu",
  "brand": "{brand}",
  "similar_brands_eu": null or ["Brand1", "Brand2", "Brand3", "Brand4", "Brand5"]
}}

Only include the JSON in your response, with no additional text before or after.
    """
}

# Create a field-specific agent
def create_field_agent(brand_name: str, field_name: str, parent_company: str = None, product_family: str = None):
    """
    Create and return an agent for researching a specific field of brand information
    
    Args:
        brand_name: The name of the brand to research
        field_name: The specific field to research
        parent_company: Optional parent company of the brand, for better context
        product_family: Optional product family of the brand, for better context
    """
    # Ensure field_name is valid
    if field_name not in PROMPT_TEMPLATES:
        raise ValueError(f"Invalid field name: {field_name}. Must be one of: {', '.join(PROMPT_TEMPLATES.keys())}")
    
    # Get search tools
    tools = get_search_tools()
    
    # Get LLM
    llm = get_llm()
    
    # Convert tools to OpenAI functions format
    functions = [format_tool_to_openai_function(t) for t in tools]
    
    # Get the field-specific prompt template and insert parent company and product family if available
    parent_company_context = f" (owned by {parent_company})" if parent_company else ""
    product_family_context = f" (a {product_family} brand)" if product_family else ""
    
    # Format the field-specific prompt template with both brand and parent company
    try:
        # If the prompt template includes all placeholders
        field_prompt = PROMPT_TEMPLATES[field_name].format(
            brand=brand_name,
            parent_company=parent_company or "the company",  # Default to generic reference if parent_company is None
            product_family=product_family or "various products"  # Default to generic reference if product_family is None
        )
    except KeyError as e:
        print(f"Error in prompt template: missing placeholder {e}")
        # Fallback to just using brand if template has issues
        field_prompt = PROMPT_TEMPLATES[field_name].format(brand=brand_name)
    
    # Create prompt template with parent company and product family context if available
    template = """You are an expert researcher on brands, companies, and their operations.

Use the provided tools to research the specific information requested about the brand {brand}{parent_company_context}{product_family_context}.

{prompt}

Research the brand: {brand}{parent_company_context}{product_family_context}

{agent_scratchpad}
    """
    
    # Create prompt template
    prompt = PromptTemplate(
        template=template,
        input_variables=["brand", "agent_scratchpad"],
        partial_variables={
            "prompt": field_prompt,
            "parent_company_context": parent_company_context,
            "product_family_context": product_family_context
        }
    )
    
    # Create the agent
    agent = (
        {
            "brand": lambda x: x["brand"],
            "agent_scratchpad": lambda x: format_to_openai_function_messages(x["intermediate_steps"])
        }
        | prompt
        | llm.bind(functions=functions)
        | OpenAIFunctionsAgentOutputParser()
    )
    
    # Create agent executor
    return AgentExecutor(agent=agent, tools=tools, verbose=True)

# Parse JSON response
def parse_json_response(response: str, field_name: str) -> Dict[str, Any]:
    """
    Parse a potentially messy JSON response from the LLM.
    """
    if not response or response.strip() == "":
        return {"field_name": field_name, "brand": None}
    
    try:
        # Try to find JSON inside a code block if present
        json_match = re.search(r"```(?:json)?\s*\n(.+?)\n\s*```", response, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            # If not in code block, try to extract JSON directly
            json_str = response
        
        # Clean up any markdown or text surrounding the JSON
        json_str = re.sub(r'^[^{]*', '', json_str)
        json_str = re.sub(r'[^}]*$', '', json_str)
        
        # Special handling for similar_brands_eu field which often has malformed arrays
        if field_name == "similar_brands_eu" and "similar_brands_eu" in json_str:
            # Fix common issue with unquoted descriptions in brackets for similar_brands_eu
            # Example: ["Brand1" (description), "Brand2" (description)]
            # Replace with: ["Brand1", "Brand2"]
            try:
                # Extract the array content
                array_match = re.search(r'"similar_brands_eu"\s*:\s*\[(.*?)\]', json_str, re.DOTALL)
                if array_match:
                    array_content = array_match.group(1)
                    # Extract just the brand names (assuming they're in quotes)
                    brand_names = re.findall(r'"([^"]+)"', array_content)
                    # Reconstruct proper JSON array
                    fixed_array = '["' + '", "'.join(brand_names) + '"]'
                    # Replace the malformed array with the fixed one
                    json_str = re.sub(r'"similar_brands_eu"\s*:\s*\[.*?\]', 
                                    f'"similar_brands_eu": {fixed_array}', 
                                    json_str, 
                                    flags=re.DOTALL)
                    print(f"Fixed similar_brands_eu array format: {fixed_array}")
            except Exception as fix_error:
                print(f"Error fixing similar_brands_eu format: {fix_error}")
        
        # Parse the JSON string
        parsed_json = json.loads(json_str)
        
        # Validate with our Pydantic model based on field_name
        field_model_map = {
            "total_employees": TotalEmployeesField,
            "employees_US": EmployeesUSField,
            "economic_impact": EconomicImpactField,
            "factory_in_france": FactoryInFranceField,
            "factory_in_EU": FactoryInEUField,
            "french_farmer": FrenchFarmerField,
            "EU_farmer": EUFarmerField,
            "similar_brands_eu": SimilarBrandsEUField,
        }
        
        if field_name in field_model_map:
            model_class = field_model_map[field_name]
            try:
                validated = model_class.model_validate(parsed_json)
                print(f"Successfully validated response against {field_name} schema")
                return validated.model_dump(exclude_unset=True)
            except Exception as validation_error:
                print(f"Schema validation warning: {validation_error}")
                return parsed_json
        else:
            print(f"No model defined for field {field_name}")
            return parsed_json
    except json.JSONDecodeError as e:
        print(f"JSON decode error: {str(e)}")
        return {
            "field_name": field_name,
            "brand": None,
            "error": "Failed to parse response"
        }

# Main function to get specific brand field information
async def get_brand_field_information(brand_name: str, field_name: str, parent_company: str = None, product_family: str = None) -> Dict[str, Any]:
    """
    Get information about a specific field for a brand
    
    Args:
        brand_name: The name of the brand to research
        field_name: The specific field to research (must be one of the supported fields)
        parent_company: Optional parent company of the brand, for better context
        product_family: Optional product family of the brand, for better context
        
    Returns:
        A dictionary containing the requested information about the brand field
    """
    # Special handling for logo_url which doesn't use an LLM
    if field_name == "logo_url":
        print(f"Handling logo_url request for {brand_name} using direct image search")
        return search_brand_logo(brand_name, parent_company, product_family)
        
    # Validate field_name for LLM-based fields
    if field_name not in PROMPT_TEMPLATES:
        valid_fields = list(PROMPT_TEMPLATES.keys()) + ["logo_url"]
        return {
            "field_name": field_name,
            "brand": brand_name,
            "error": f"Invalid field name. Must be one of: {', '.join(valid_fields)}"
        }
    
    try:
        # Create the field-specific agent with parent company and product family info if available
        agent = create_field_agent(brand_name, field_name, parent_company, product_family)
        
        # Prepare context with parent company and product family if available
        context = {"brand": brand_name}
        if parent_company:
            print(f"Including parent company '{parent_company}' in context for brand '{brand_name}'")
            context["parent_company"] = parent_company
        if product_family:
            print(f"Including product family '{product_family}' in context for brand '{brand_name}'")
            context["product_family"] = product_family
            
        # Get response from agent
        result = agent.invoke(context)
        response = result["output"]
        
        # Parse the response
        parsed_response = parse_json_response(response, field_name)
        
        # Ensure the brand name is included
        if "brand" not in parsed_response or not parsed_response["brand"]:
            parsed_response["brand"] = brand_name
            
        # Ensure the field_name is included
        if "field_name" not in parsed_response or not parsed_response["field_name"]:
            parsed_response["field_name"] = field_name
            
        return parsed_response
    except Exception as e:
        print(f"Error getting brand field information: {str(e)}")
        return {
            "field_name": field_name,
            "brand": brand_name,
            "error": f"Failed to get brand field information: {str(e)}"
        }

# Simple test function
if __name__ == "__main__":
    import asyncio
    
    async def test():
        # Test with a brand and a specific field
        brand = "Nestl√©"
        field = "factory_in_france"
        result = await get_brand_field_information(brand, field)
        print(f"\nResults for {brand}, field {field}:")
        print(json.dumps(result, indent=2, ensure_ascii=False))
    
    asyncio.run(test())
